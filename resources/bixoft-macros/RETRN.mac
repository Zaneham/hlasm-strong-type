.*
.* This macro is free software; you can redistribute it and/or modify
.* it under the terms of the GNU General Public License as published by
.* the Free Software Foundation; either version 2 of the License
.* or (at your option) any later version.
.* The license text is available at the following internet addresses:
.* - http://www.bixoft.com/english/gpl.htm
.* - http://fsf.org
.* - http://opensource.org
.*
.* This macro is distributed in the hope that it will be useful,
.* but WITHOUT ANY WARRANTY; without even the implied warranty of
.* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
.* See the GNU General Public License for more details.
.*
.* You should have received a copy of the GNU General Public License
.* along with this program; if not, write to either of the following:
.* the Free Software Foundation, Inc.      B.V. Bixoft
.* 59 Temple Place, Suite 330              Rogge 9
.* Boston, MA 02111-1307                   7261 JA Ruurlo
.* United States of America                The Netherlands
.*
.*                                         e-mail: bixoft@bixoft.nl
.*                                         phone : +31-6-22755401
.*
.**********************************************************************
.*
.* Bixoft eXtended Assembly language
.* Licensed material - Property of B.V. Bixoft
.*
.* This macro can be licensed or used on an as-is basis.
.* No warranty, neither implicit nor explicit, is given.
.* It remains your own responsibility to ensure the correct
.* working of any program using this macro.
.*
.* Suggestions for improvement are always welcome at
.* http://www.bixoft.com  or mail to  bixoft@bixoft.nl
.*
.* (C) Copyright B.V. Bixoft, 1999
.**********************************************************************
         MACRO
.*
.* This macro generates code for exiting the active module
.*
&LABEL   RETRN &RC=0,                  * Returncode, (reg), or *       *
               &REASON=,               * Reasoncode, (reg), or *       *
               &RETPTR=,               * Return ptr value, (reg), or * *
               &WORKAREA=FREE,         * FREE or NOFREE                *
               &INLINE=YES             * YES or NO
.*
.* &RC   specifies the returncode. Specification of * equals to (R15)
.*       If omitted a returncode of 0 will be generated by default.
.* &REASON specifies the reasoncode. Specification of * equals to (R0)
.*         If omitted, R0 will be restored to the contents at entry.
.* &RETPTR specifies a pointer value to be returned in R1.
.*         Specification of * equals to (R1).
.*         If omitted, R1 will be restored to the contents at entry.
.* &WORKAREA specifies whether or not the area allocated by PGM
.*           is to be released.
.* &INLINE if specified as YES, a branch will be generated to an
.*         out-of-line routine which performs the requested function.
.*         if specified as NO the required out-of-line routine will
.*         be generated. INLINE=NO should be specified only by the END
.*         macro.
.*
.**********************************************************************
.*
.*       IMPORTANT NOTICE
.*       ========= ======
.*
.* Code below checks whether 'USER' accepted the terms and conditions
.* of the license for the BXA macro library. This code is to be treated
.* as part of the Copyright Notice and therefore may not be changed
.* or disabled in any way.
.*
.**********************************************************************
         GBLA  &BXA_RC                 * Returncode from CHKLIC
         CHKLIC RETRN                  * Check license acceptance
         AIF   (&BXA_RC NE 0).MEND
.**********************************************************************
.*
.* End of special code that is part of the Copyright Notice
.*
.**********************************************************************
.*
.* Define variables
         GBLB  &SP_SHOWALL             * Option from PGM
         GBLC  &SYSASCE                * ASC-environment: P or AR
         GBLC  &BXA_WALEN              * Worka area length
         GBLC  &BXA_ENTRY              * Entry mode
         GBLA  &BXA_SAVES              * Nr of internal save areas
         GBLC  &BXA_WORKPTR(3)         * Pointer to work area
         GBLC  &BXA_SUBR               * Current subroutine name
         GBLC  &BXA_PGM_LABEL          * Label of CSECT from PGM macro
         GBLC  &BXA_WALAB              * Label of workarea
         LCLA  &I                      * INDEX for BXA_RETRN_...
         GBLC  &BXA_RETRN_RC(5)        * Returncodes
         GBLC  &BXA_RETRN_RP(5)        * Return pointers
         GBLC  &BXA_RETRN_RS(5)        * Reasoncodes
         GBLC  &BXA_RETRN_WA(5)        * WORKAREA parameters
         GBLC  &BXA_RETRN_LBL(5)       * Labels for out-of-line rout.
         GBLA  &BXA_NUMVAL             * Returnvalue from EQUREG
         LCLC  &ARG                    * Some argument
         LCLC  &_RC                    * Returncode register
         LCLC  &_RS                    * Reasoncode register
         LCLC  &_RP                    * Return pointer register
         LCLC  &_WR1                   * Work register 1
         LCLC  &_WR2                   * Work register 2
.*
.* Check workarea parameter
         AIF   ('&WORKAREA' EQ 'FREE').NOERR1
         AIF   ('&WORKAREA' EQ 'NOFREE').NOERR1A
.ERR1A   MNOTE 8,'Workarea parameter must specify FREE or NOFREE'
         AGO   .NOERR1
.NOERR1A ANOP
         AIF   ('&BXA_ENTRY' EQ 'FRR').ERR1B
         AIF   ('&BXA_ENTRY' EQ 'RESMGR').ERR1B
         AIF   ('&BXA_ENTRY' EQ 'RMTR').ERR1B
         AIF   ('&BXA_ENTRY' EQ 'SPCR').ERR1B
         AIF   ('&BXA_ENTRY' EQ 'SRB').ERR1B
         AIF   ('&BXA_ENTRY' EQ 'SVC').ERR1B
         AGO   .NOERR1
.ERR1B   MNOTE 8,'Workarea parameter must specify FREE for &BXA_ENTRY p*
               rograms'
.NOERR1  ANOP  ,
.*
.* Check subroutine name
         AIF   ('&BXA_SUBR' EQ '*MAIN').NOERR2
.ERR2    MNOTE 8,'RETRN must not be issued within a subroutine'
.NOERR2  ANOP
.*
.* Check nesting level
         AIF   (&SYSNEST EQ 1).NOERR3
         AIF   ('&INLINE' EQ 'NO').NOERR3
.ERR3    MNOTE 8,'RETRN must not be issued from within another macro'
.NOERR3  ANOP
.*
.* Check inline parameter
         AIF   ('&INLINE' EQ 'NO').NOERR4
         AIF   ('&INLINE' EQ 'YES').NOERR4
.ERR4    MNOTE 8,'INLINE parameter must specify either YES or NO'
         MEXIT
.NOERR4  ANOP
.*
.* Check RC parameter
         AIF   (K'&RC EQ 0).NOERR5
         AIF   ('&BXA_ENTRY' EQ 'SRB').ERR5C
         AIF   ('&BXA_ENTRY' EQ 'RMTR').ERR5C
         AIF   ('&RC'(1,1) NE '(').NOERR5
         AIF   (N'&RC NE 1).ERR5A
         CHKREG &RC(1),g
         AIF   (&BXA_RC EQ 8).ERR5B
         AGO   .NOERR5
.ERR5A   MNOTE 4,'Only 1 register can be specified on RC, remainder ign*
               ored'
         AGO   .NOERR5
.ERR5B   ANOP
&ARG     SETC  (DOUBLE '&RC(1)')
         MNOTE 8,'Register &ARG is not a valid register'
         MEXIT
.ERR5C   ANOP  ,
         AIF   ('&RC' EQ '0').NOERR5
         MNOTE 8,'RC-parameter not allowed for SRB/RMTR-type routines'
.NOERR5  ANOP
.*
.* Check REASON parameter
         AIF   (K'&REASON EQ 0).NOERR6
         AIF   ('&BXA_ENTRY' EQ 'FRR').ERR6C
         AIF   ('&BXA_ENTRY' EQ 'SRB').ERR6C
         AIF   ('&BXA_ENTRY' EQ 'RESMG').ERR6C
         AIF   ('&BXA_ENTRY' EQ 'RMTR').ERR6C
         AIF   ('&REASON'(1,1) NE '(').NOERR6
         AIF   (N'&REASON NE 1).ERR6A
         CHKREG &REASON(1),g
         AIF   (&BXA_REASON EQ 8).ERR6B
         AGO   .NOERR6
.ERR6A   MNOTE 4,'Only 1 register can be specified on REASON, remainder*
                ignored'
         AGO   .NOERR6
.ERR6B   ANOP
&ARG     SETC  (DOUBLE '&REASON(1)')
         MNOTE 8,'Register &ARG is not a valid register'
         MEXIT
.ERR6C   MNOTE 8,'REASON-parameter not allowed for &BXA_ENTRY type of r*
               outine'
.NOERR6  ANOP
.*
.* Check RETPTR parameter
         AIF   (K'&RETPTR EQ 0).NOERR7
         AIF   ('&BXA_ENTRY' EQ 'FRR').ERR7C
         AIF   ('&BXA_ENTRY' EQ 'SRB').ERR7C
         AIF   ('&BXA_ENTRY' EQ 'RMTR').ERR7C
         AIF   ('&BXA_ENTRY' EQ 'RESMGR').ERR7C
         AIF   ('&RETPTR'(1,1) NE '(').NOERR7
         AIF   (N'&RETPTR NE 1).ERR7A
         CHKREG &RETPTR(1),g
         AIF   (&BXA_RC EQ 8).ERR7B
         AGO   .NOERR7
.ERR7A   MNOTE 4,'Only 1 register can be specified on RETPTR, remainder*
                ignored'
         AGO   .NOERR7
.ERR7B   ANOP
&ARG     SETC  (DOUBLE '&RETPTR(1)')
         MNOTE 8,'Register &ARG is not a valid register'
         MEXIT
.ERR7C   MNOTE 8,'RETPTR-parameter not allowed for &BXA_ENTRY type of r*
               outine'
.NOERR7  ANOP
.*
.* INLINE-parameter determines further expansion of this macro
         AIF   ('&INLINE' EQ 'YES').INLINE
         AIF   ('&INLINE' EQ 'NO').OUTLINE
         MNOTE 12,'Internal error'
         MEXIT
.*
.INLINE  ANOP
&I       SETA  N'&BXA_RETRN_LBL+1      * Point firrst free element
&BXA_RETRN_LBL(&I) SETC '_RETRN&SYSNDX' * Generate label for routine
&BXA_RETRN_RC(&I)  SETC '&RC'          * Copy returncode parameter
&BXA_RETRN_RS(&I)  SETC '&REASON'      * Copy reasoncode parameter
&BXA_RETRN_RP(&I)  SETC '&RETPTR'      * Copy returnpointer parameter
&BXA_RETRN_WA(&I)  SETC '&WORKAREA'    * Copy workarea parameter
.*
.* Now replace R12 with the intended target address and branch to it
         L     R12,=AL4(_RETRN&SYSNDX) * Load out-of-line routine addr
         BR    R12                     * And execute it
         MEXIT
.*
.* Generate label if one is specified
.OUTLINE ANOP
&LABEL   LABEL H                       * Re-align on halfword boundary
         DROP  ,                       * Drop all USINGs
         USE   &LABEL,R12              * Set code addressable
         USE   &BXA_WALAB,R13,         * Set workarea addressable      *
               START=&BXA_WALAB+SAVEPRFX_LEN * upward from savearea
.*
.* We must assign 5 registers:
.* 1 for the returncode to be returned in R15    - &_RC
.* 1 for the reasoncode to be returned in R0     - &_RS
.* 1 for the return pointer to be returned in R1 - &_RP
.* 2 work registers                              - &_WR1, &_WR2
.* Defaults are as follows:
.* &_RC: register specified, otherwise lowest available in range R1-R11
.* &_RS: register specified, otherwise lowest available in range R1-R11
.* &_RP: register specified, otherwise lowest available in range R1-R11
.* &_WR1,&_WR2: lowest available in range R1-R11 after assigning
.*              &_RC, &_RS, and &_RP
.*
.* Check which register has been assigned to the return code
         AIF   ('&RC' EQ '*').TSTRC_R15 * R15
         AIF   ('&RC'(1,1) EQ '(').TSTRC_REG * Register
         AGO   .TSTRC_OK               * No register to USE
.TSTRC_R15 ANOP ,                      *
&_RC     SETC  'R15'                   * Assign R15 for returncode
         USE   R15                     * R15 contains return code
         AGO   .TSTRC_OK               *
.TSTRC_REG ANOP ,                      *
&_RC     SETC  '&RC(1)'                * Assign reg for returncode
         USE   &RC(1)                  * Some register contains retcd
.TSTRC_OK ANOP ,                       *
.*
.* Check which register has been assigned to the reason code
         AIF   (K'&REASON EQ 0).TSTRS_OK * No reason code?
         AIF   ('&REASON' EQ '*').TSTRS_R0 * R0
         AIF   ('&REASON'(1,1) EQ '(').TSTRS_REG * Register
         AGO   .TSTRS_OK               * No register to USE
.TSTRS_R0 ANOP ,                       *
&_RS     SETC  'R0'                    * Assign R0 for reasoncode
         USE   R0                      * R0 contains reason code
         AGO   .TSTRS_OK               *
.TSTRS_REG ANOP ,                      *
&_RS     SETC  '&REASON(1)'            * Assign reg for reasoncode
         USE   &REASON(1)              * Some register contains reason
.TSTRS_OK ANOP ,                       *
.*
.* Check which register has been assigned to the return pointer value
         AIF   (K'&RETPTR EQ 0).TSTRP_OK * Return pointer specified?
         AIF   ('&RETPTR' EQ '*').TSTRP_R1 * R1
         AIF   ('&RETPTR'(1,1) EQ '(').TSTRP_REG * Register
         AGO   .TSTRP_OK               * No register to USE
.TSTRP_R1 ANOP ,                       *
&_RP     SETC  'R1'                    * Assign R1 for returnpointer
         USE   R1                      * R1 contains return pointer
         AGO   .TSTRP_OK               *
.TSTRP_REG ANOP ,                      *
&_RP     SETC  '&RETPTR(1)'            * Assign reg for return pointer
         USE   &RETPTR(1)              * Some register contains retptr
.TSTRP_OK ANOP ,                       *
.*
.* Assign two work registers (used for addressing)
         EQUREG R0=NO                  * Find a work register
&_WR1    SETC  'R&BXA_NUMVAL'          *  create register name
         USE   &_WR1                   * and set it in use
         EQUREG R0=NO                  * And another one
&_WR2    SETC  'R&BXA_NUMVAL'          *  create register name
         USE   &_WR2                   * and set it in use
.*
.* When in access register mode, the associated ARs must be cleared
         AIF   ('&SYSASCE' NE 'AR').NOTAR
         CLEAR A&_WR1
         CLEAR A&_WR2
.NOTAR   ANOP  ,
.*
.* Assign register for return code (unless already valid)
         AIF   (K'&_RC GT 0)._RCREG    * Returncode in a register?
         EQUREG ,                      * No: find a register
&_RC     SETC  'R&BXA_NUMVAL'          * Create register name
         AIF   ('&RC' EQ '0').RC_0     * Set to 0
         LA    &_RC,&RC                * Load return code into register
         USE   &_RC                    * Set register in use
         AGO   ._RCOK
.RC_0    ANOP
         CLEAR &_RC                    * Set returncode to zero
         USE   &_RC                    * Set register in use
         AGO   ._RCOK
._RCREG  ANOP  ,                       * Check validity of register
.* For WORKAREA=FREE registers 14 thru 1 cannot be used
         AIF   ('&WORKAREA' EQ 'NOFREE')._RCOK * Nofree: no requirement
         CHKREG &_RC,g                 * Valid register?
         AIF   (&BXA_NUMVAL LT 2).RCREG * Allocate another
         AIF   (&BXA_NUMVAL GT 13).RCREG * Allocate another
         AGO   ._RCOK                  * Reg 2-13: OK
.RCREG   ANOP
         EQUREG ,                      * No: find a register
&I       SETA  &BXA_NUMVAL             * Save new register nr
         LR    R&I,&_RC                * Copy retcd to safe register
         DROP  &_RC                    * Set register available
&_RC     SETC  'R&I'                   * Create register name
         USE   &_RC                    * And set register in use
._RCOK   ANOP
.*
.* Assign register for reason code (unless already done)
         AIF   (K'&REASON EQ 0)._RSOK  * Reasoncode specified?
         AIF   (K'&_RS GT 0)._RSREG    * Reasoncode in register?
         EQUREG ,                      * No: find a register
&_RS     SETC  'R&BXA_NUMVAL'          * Create register name
         AIF   ('&REASON' EQ '0').RS_0 * Set to 0
         LA    &_RS,&REASON            * Load reason code into register
         USE   &_RS                    * Set register in use
         AGO   ._RSOK
.RS_0    ANOP
         CLEAR &_RS                    * Set reasoncode to zero
         USE   &_RS                    * Set register in use
         AGO   ._RSOK
._RSREG  ANOP  ,                       * Check validity of register
.* For WORKAREA=FREE registers 14 thru 1 cannot be used
         AIF   ('&WORKAREA' EQ 'NOFREE')._RSOK * Nofree: no requirement
         CHKREG &_RS,g                 * Valid register?
         AIF   (&BXA_NUMVAL LT 2).RSREG * Allocate another
         AIF   (&BXA_NUMVAL GT 13).RSREG * Allocate another
         AGO   ._RSOK                  * Reg 2-13: OK
.RSREG   ANOP
         EQUREG ,                      * No: find a register
&I       SETA  &BXA_NUMVAL             * Save new register nr
         LR    R&I,&_RS                * Copy reason to safe register
         DROP  &_RS                    * Set register available
&_RS     SETC  'R&I'                   * Create register name
         USE   &_RS                    * And set register in use
._RSOK   ANOP
.*
.* Assign register for return pointer (unless already done)
         AIF   (K'&RETPTR EQ 0)._RPOK  * Return ptr specified?
         AIF   (K'&_RP GT 0)._RPREG    * Return ptr in register?
         EQUREG ,                      * No: find a register
&_RP     SETC  'R&BXA_NUMVAL'          * Create register name
         AIF   ('&RETPTR' EQ '0').RP_0 * Set to 0
         LA    &_RP,=AL4(&RETPTR)      * Load return ptr into register
         USE   &_RP                    * Set register in use
         AGO   ._RPOK
.RP_0    ANOP
         CLEAR &_RP                    * Set return pointer to zero
         USE   &_RP                    * Set register in use
         AGO   ._RPOK
._RPREG  ANOP  ,                       * Check validity of register
.* For WORKAREA=FREE registers 14 thru 1 cannot be used
         AIF   ('&WORKAREA' EQ 'NOFREE')._RPOK * Nofree: no requirement
         CHKREG &_RP,g                 * Valid register?
         AIF   (&BXA_NUMVAL LT 2).RPREG * Allocate another
         AIF   (&BXA_NUMVAL GT 13).RPREG * Allocate another
         AGO   ._RPOK                  * Reg 2-13: OK
.RPREG   ANOP
         EQUREG ,                      * No: find a register
&I       SETA  &BXA_NUMVAL             * Save new register nr
         LR    R&I,&_RP                * Copy retptr to safe register
         DROP  &_RP                    * Set register available
&_RP     SETC  'R&I'                   * Create register name
         USE   &_RP                    * And set register in use
._RPOK   ANOP
.*
.* Check the internal save-areas
         AIF   ('&BXA_ENTRY' EQ 'SUBR' AND &BXA_SAVES EQ 0).SUBRSAV
         AIF   (&BXA_SAVES EQ 0).NOSAVES
* All subroutines must have completed
         LT    &_WR1,SAVEINTF          * Retrieve ptr to internal SA's
         ABND  Z                       * If invalid: abend!
         AIF   ('&BXA_ENTRY' EQ 'SUBR').SUBRSAV
         LT    &_WR2,SAVEINTU          * Pointer to last used is zero?
         ABND  NZ                      * No: not all subr's ended!
         AGO   .NOSAVES                * Skip SUBR logic
.*
.SUBRSAV ANOP
         LT    &_WR1,SAVEINTU          * Pointer to last used is zero?
         ABND  Z                       * Yes: invalid for SUBR-type pgm
_LOOP&SYSNDX LABEL ,
         DROP  &_WR2                   * Drop reg to change it
         AIF   (&BXA_SAVES EQ 0).NOSAVES
         LR    &_WR2,&_WR1             * Point to SA on chain
SA       USE   SAVEAREA,&_WR2          * and set it addressable
         LT    &_WR1,SA.SAVENEXT       * Is there a next SA?
         BNZ   _LOOP&SYSNDX            * Yes: runchain
         LA    &_WR1,&BXA_WALEN-SAVEAREA_LEN * Offset in dynamic area
         SR    &_WR2,&_WR1             * Point to start of area
         DROP  SA
INT      USE   BXASAVE,&_WR2           * Set area addressable
         CLC   INT.SAVEID,=CL8'&BXA_PGM_LABEL' * Id is correct?
         ABND  NE                      * If not: internal error
         CLC   SAVEINTU,INT.SAVEPTSA   * all subrs ended?
         ABND  NE                      * No: must be an error!
         DROP  &_WR1                   * Drop register to change it
         L     &_WR1,INT.SAVEPREV      * Point to preceding SA on chain
PRV      USE   SAVEAREA,&_WR1          * and set it addressable
         CLEAR PRV.SAVENEXT,,XC        * Detach our subchain
         DROP  PRV                     * SAVEAREA,R4 (now end-of-chain)
         USE   &_WR1                   * Tell asm not to realloc reg.
         DROP  INT                     * BXASAVE,R5 = whole dyn.area
         USE   &_WR2                   * Tell asm not to realloc reg.
.NOSAVES ANOP
.*
         AIF   ('&WORKAREA' EQ 'NOFREE').NOFREE
         AIF   ('&BXA_ENTRY' EQ 'SUBR' AND &BXA_SAVES EQ 0).NOFREE
*
* Release dynamically allocated storage
         AIF   ('&BXA_ENTRY' EQ 'SUBR').WR2OK * For SUBR WR2 is ok
         DROP  &_WR2                   * Drop reg to change it
         LR    &_WR2,R13               * Copy workarea pointer
         DEC   &_WR2,SAVEPRFX_LEN      * And adjust for prefix area
.WR2OK   ANOP  ,                       *
.*
.* If a pointer is known to exist: reset it to zeros
         AIF   (K'&BXA_WORKPTR(3) EQ 0)._NOPTR
* First reset pointer to zeros
HDR      USE   BXASAVE,&_WR2           * Set area addressable
         LT    &_WR1,HDR.SAVEPTPT      * Get ptr to area with ptr to us
         ABND  Z                       * If invalid abend program
         XC    0(4,&_WR1),0(&_WR1)     * Reset pointer to zero
         DROP  HDR                     * BXASAVE,R5 = whole dyn.area
         USE   &_WR2                   * Tell asm not to change this 1
* Then free allocated storage
._NOPTR  ANOP
.* Free allocated storage
.* For SUBPGM's with FREE: Hold address of previous save-area in WR1
         AIF   ('&BXA_ENTRY' NE 'SUBPGM' AND                           *
               '&BXA_ENTRY' NE 'RESMGR' AND                            *
               '&BXA_ENTRY' NE 'FRR').NOSUB
         L     &_WR1,SAVEPREV          * Save address of previous SA
.NOSUB   ANOP  ,                       *
         AIF   ('&BXA_ENTRY' NE 'SRB' AND '&BXA_ENTRY' NE 'RMTR').NOSRB
         L     &_WR1,SAVEHDR           * Reload return address
         CLEAR SAVEHDR                 * Wipe header of save area
.NOSRB   ANOP  ,                       *
.*
         STORAGE RELEASE,              * Free the acquired             *
               ADDR=(&_WR2),           *    storage area               *
               LENGTH=&BXA_WALEN       *
.NOFREE  ANOP  ,                       *
.*
.* Generate different code for returning to caller depending on ENTRY
         AIF   ('&BXA_ENTRY' EQ 'FRR').SUBPGM
         AIF   ('&BXA_ENTRY' EQ 'MAIN').MAIN
         AIF   ('&BXA_ENTRY' EQ 'RESMGR').SUBPGM
         AIF   ('&BXA_ENTRY' EQ 'RMTR').SRB
         AIF   ('&BXA_ENTRY' EQ 'SPCR').MAIN
         AIF   ('&BXA_ENTRY' EQ 'SRB').SRB
         AIF   ('&BXA_ENTRY' EQ 'SUBPGM').SUBPGM
         AIF   ('&BXA_ENTRY' EQ 'SUBR').SUBR
         AIF   ('&BXA_ENTRY' EQ 'SVC').SVC
         MNOTE 12,'Internal error'
         MEXIT
.*
.SUBPGM  ANOP
*
* Set ret/reason-codes in R15/R0, restore registers, then return
.* If WORKAREA=FREE, ptr to previous SA in &_WR1
.*        otherwise, ptr to previous SA in current SA
         AIF   ('&WORKAREA' EQ 'FREE').FROMWR1
         L     R13,SAVEPREV            * Point to previous SA
         AGO   .R13OK
.FROMWR1 ANOP
         LR    R13,&_WR1               * Restore R13 (prev.savearea)
.R13OK   ANOP
         DROP  R13                     * Drop to swap using status
         USE   SAVEAREA,R13            * R13 now points to prev.SA
         L     R14,SAVEDR14            * Restore R14
         CPY   R15,&_RC,NOWARN         * Copy returncode to R15
.* Determine how to load R0 and R1
&_WR2    SETC  'R2'                    * Start register for LM
         AIF   (K'&REASON GT 0 AND K'&RETPTR GT 0).SPRSRP
         AIF   (K'&REASON GT 0 AND K'&RETPTR EQ 0).SPRS
         AIF   (K'&REASON EQ 0 AND K'&RETPTR GT 0).SPRP
.* Neither reason nor retptr specified
&_WR2    SETC  'R0'                    * Reload registers 0-12
         AGO   .SP_LM                  *
.SPRSRP  ANOP  ,                       * Both reason and retptr
         CPY   R0,&_RS,NOWARN          * Copy reasoncode to R0
         CPY   R1,&_RP,NOWARN          * Copy return ptr to R1
         AGO   .SP_LM                  *
.SPRS    ANOP  ,                       * Only reason specified
         CPY   R0,&_RS,NOWARN          * Copy reasoncode to R0
&_WR2    SETC  'R1'                    * Reload registers 1-12
         AGO   .SP_LM                  *
.SPRP    ANOP  ,                       * Only retptr specified
         L     R0,SAVEDR0              * Restore caller's R0
         CPY   R1,&_RP,NOWARN          * Copy return ptr to R1
.SP_LM   ANOP  ,                       *
         LM    &_WR2,R12,SAVED&_WR2    * Restore all other registers
         BR    R14                     * Return to caller
         DROP  R13                     * SAVEAREA no longer needed
.*
         AGO   .LTORG
.*
.SUBR    ANOP
*
* Set return/reason-codes in R15/R0, restore registers, then return
         DROP  &_WR1                   * Drop register to change it
         L     &_WR1,SAVEINTU          * Point to last-used internal SA
SA       USE   SAVEAREA,&_WR1          * Set previous SA addressable
         MVC   SAVEINTU,SA.SAVEPREV    * Set previous SA last-used
         L     R14,SA.SAVEDR14         * Restore R14
         CPY   R15,&_RC,NOWARN         * Copy returncode to R15
.* Determine how to load R0 and R1
&_WR2    SETC  'R2'                    * Start register for LM
         AIF   (K'&REASON GT 0 AND K'&RETPTR GT 0).SRRSRP
         AIF   (K'&REASON GT 0 AND K'&RETPTR EQ 0).SRRS
         AIF   (K'&REASON EQ 0 AND K'&RETPTR GT 0).SRRP
.* Neither reason nor retptr specified
&_WR2    SETC  'R0'                    * Reload registers 0-12
         AGO   .SR_LM                  *
.SRRSRP  ANOP  ,                       * Both reason and retptr
         CPY   R0,&_RS,NOWARN          * Copy reasoncode to R0
         CPY   R1,&_RP,NOWARN          * Copy return ptr to R1
         AGO   .SR_LM                  *
.SRRS    ANOP  ,                       * Only reason specified
         CPY   R0,&_RS,NOWARN          * Copy reasoncode to R0
&_WR2    SETC  'R1'                    * Reload registers 1-12
         AGO   .SR_LM                  *
.SRRP    ANOP  ,                       * Only retptr specified
         L     R0,SA.SAVEDR0           * Restore caller's R0
         CPY   R1,&_RP,NOWARN          * Copy return ptr to R1
.SR_LM   ANOP  ,
         LM    &_WR2,R12,SA.SAVED&_WR2 * Restore all other registers
         BR    R14                     * Return to caller
         DROP  SA                      * SAVEAREA,R4 no longer needed
         USE   &_WR1                   * Tell asm not to reallocate reg
         AGO   .LTORG
.*
.MAIN    ANOP
*
* Load returncode and return to caller
         CPY   R15,&_RC,NOWARN         * Load returncode
.* Determine how to load R0 and R1
         AIF   (K'&REASON GT 0 AND K'&RETPTR GT 0).MNRSRP
         AIF   (K'&REASON GT 0 AND K'&RETPTR EQ 0).MNRS
         AIF   (K'&REASON EQ 0 AND K'&RETPTR GT 0).MNRP
.* Neither reason nor retptr specified
         EREG  R0,R1                   * Reload registers 0-1
         AGO   .MN_PR
.MNRSRP  ANOP  ,                       * Both reason and retptr
         CPY   R0,&_RS,NOWARN          * Copy reasoncode to R0
         CPY   R1,&_RP,NOWARN          * Copy return ptr to R1
         AGO   .MN_PR                  *
.MNRS    ANOP  ,                       * Only reason specified
         CPY   R0,&_RS,NOWARN          * Copy reasoncode to R0
         EREG  R1,R1                   * Restore caller's R1
         AGO   .MN_PR                  *
.MNRP    ANOP  ,                       * Only retptr specified
         EREG  R0,R0                   * Restore caller's R0
         CPY   R1,&_RP,NOWARN          * Copy return ptr to R1
.MN_PR   ANOP  ,
         PR    ,                       *  and return to caller
         AGO   .LTORG
.*
.SVC     ANOP
*
* Load returncode and return to caller
         CPY   R15,&_RC,NOWARN         * Load returncode
.* Reasoncode specified for R0?
         AIF   (K'&REASON EQ 0).SVCNORS
         CPY   R0,&_RS,NOWARN          * Load reasoncode
.SVCNORS ANOP  ,
.* Return pointer specified for R1?
         AIF   (K'&RETPTR EQ 0).SVCNORP
         CPY   R1,&_RP,NOWARN          * Load return pointer
.SVCNORP ANOP  ,
*
* Return to caller
         SVC   3                       * Pop RB
         MEXIT ,                       *
*
.SRB     ANOP  ,                       *
*
* Clear retcode register and return to system
         CPY   R15,&_RC,NOWARN         * Copy saved retcode 0
         CPY   R14,&_WR1               * Copy return register
         BR    R14                     * and return
*
.LTORG   ANOP  ,                       *
         LTORG ,                       * Literal pool for this routine
         DROP  ,                       * Drop all registers
.*
.MEND    MEND
